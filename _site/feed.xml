<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/otter_song.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/otter_song.github.io/" rel="alternate" type="text/html" /><updated>2025-12-04T11:30:06+09:00</updated><id>http://localhost:4000/otter_song.github.io/feed.xml</id><title type="html">Otter Song’s Technology Blog</title><subtitle>Development Journal</subtitle><author><name>otter song</name></author><entry><title type="html">Development Weekly Diary</title><link href="http://localhost:4000/otter_song.github.io/weekly_diary/development-diary/" rel="alternate" type="text/html" title="Development Weekly Diary" /><published>2025-12-01T18:00:00+09:00</published><updated>2025-12-01T18:00:00+09:00</updated><id>http://localhost:4000/otter_song.github.io/weekly_diary/development-diary</id><content type="html" xml:base="http://localhost:4000/otter_song.github.io/weekly_diary/development-diary/"><![CDATA[<div style="text-align: center;">
  <h2><strong>Weekly Development Log</strong></h2>
</div>

<p><br />
📆
<strong>2025</strong> 
<strong>12 · 04 · THU</strong></p>

<hr />
<h2 id="-client-proxy란">🔌 Client Proxy란?</h2>

<p>NestJS 마이크로서비스 간에 <strong>메시지 기반 통신(TCP, Redis, NATS, Kafka, RabbitMQ 등)</strong> 을 사용할 때 요청을 보내는 도구이다.</p>

<p>HTTP 서버끼리 REST로 통신하는 방식이 아닌,<br />
NestJS 자체의 <strong>Microservices 메시징 시스템</strong>을 사용할 때 등장한다.</p>

<p><br /></p>

<h3 id="-서비스-간-흐름-구조">📡 서비스 간 흐름 구조</h3>

<pre><code class="language-txt">API Gateway (REST)
        ↓
Payment Microservice
        ↓
User Microservice
        ↓
Notification Microservice
</code></pre>

<p>API Gateway는 각 마이크로서비스에 요청을 전달해야 하고,<br />
이때 HTTP 대신 <strong>메시지 기반 통신(ClientProxy)</strong> 을 사용하는 구조다.</p>

<p><br /></p>

<hr />

<h2 id="️-clientproxy-동작-방식">⚙️ ClientProxy 동작 방식</h2>

<p>ClientProxy는 두 가지 방식으로 메시지를 전송한다.</p>

<h3 id="1-send--rpc-요청응답-request--response">1) <code class="language-plaintext highlighter-rouge">send()</code> — RPC 요청/응답 (Request → Response)</h3>

<p>요청 후 <strong>응답을 기다리는 방식</strong></p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">get_user</span><span class="dl">'</span><span class="p">,</span> <span class="nx">userId</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h3 id="2-emit--이벤트-발행-fire-and-forget">2) <code class="language-plaintext highlighter-rouge">emit()</code> — 이벤트 발행 (Fire-and-forget)</h3>

<p>응답 없이 <strong>이벤트만 전송</strong></p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">user_created</span><span class="dl">'</span><span class="p">,</span> <span class="nx">userData</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<hr />

<h2 id="-clientproxy-생성-방법">🏗 ClientProxy 생성 방법</h2>

<h3 id="1-clientsmoduleregister로-설정">1) ClientsModule.register()로 설정</h3>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">constructor</span><span class="p">(</span>
    <span class="p">@</span><span class="nd">Inject</span><span class="p">(</span><span class="dl">'</span><span class="s1">USER_SERVICE</span><span class="dl">'</span><span class="p">)</span> <span class="k">private</span> <span class="nx">client</span><span class="p">:</span> <span class="nx">ClientProxy</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<h3 id="2-예시-redis-transport">2) 예시: Redis Transport</h3>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ClientsModule</span><span class="p">.</span><span class="nf">register</span><span class="p">([</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">USER_SERVICE</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">transport</span><span class="p">:</span> <span class="nx">Transport</span><span class="p">.</span><span class="nx">REDIS</span><span class="p">,</span>
        <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">host</span><span class="p">:</span> <span class="dl">'</span><span class="s1">localhost</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">port</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">},</span>
<span class="p">])</span>
</code></pre></div></div>

<p><br /></p>

<hr />

<h2 id="-실-사용-예시">🧪 실 사용 예시</h2>

<h3 id="-gateway--user-service-유저-정보-가져오기">📍 Gateway → User Service: 유저 정보 가져오기</h3>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">userClient</span>
    <span class="p">.</span><span class="nf">send</span><span class="p">({</span> <span class="na">cmd</span><span class="p">:</span> <span class="dl">'</span><span class="s1">get-user</span><span class="dl">'</span> <span class="p">},</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">10</span> <span class="p">})</span>
    <span class="p">.</span><span class="nf">toPromise</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="-이벤트-발행">📍 이벤트 발행</h3>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">userClient</span><span class="p">.</span><span class="nf">emit</span><span class="p">(</span>
    <span class="p">{</span> <span class="na">cmd</span><span class="p">:</span> <span class="dl">'</span><span class="s1">user-updated</span><span class="dl">'</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">현승</span><span class="dl">'</span> <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<hr />

<h2 id="-clientproxy를-사용하는-이유">🚀 ClientProxy를 사용하는 이유</h2>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NestJS는 마이크로서비스를 단순한 HTTP 서버가 아닌
“메시지 기반 서비스”로 구성하기 위한 기능을 지원한다.
</code></pre></div></div>

<h3 id="주요-장점">주요 장점</h3>

<ul>
  <li>서비스 간 결합도 감소(Decoupling)</li>
  <li>비동기 메시징 기반</li>
  <li>트래픽 비동기 처리</li>
  <li>Redis, Kafka, NATS 등 브로커 사용 가능</li>
  <li>마이크로서비스 확장성 증가</li>
  <li>장애 허용성 향상</li>
</ul>

<p><br /></p>

<hr />

<h2 id="-언제-사용하나">💡 언제 사용하나?</h2>

<p>일반적으로 <strong>같은 도메인이 아닌 다른 도메인</strong> 간 통신할 때 사용<br />
(ex. <code class="language-plaintext highlighter-rouge">curation ↔ spot</code>, <code class="language-plaintext highlighter-rouge">gateway ↔ payment</code>)</p>

<hr />]]></content><author><name>otter song</name></author><category term="weekly_diary" /><summary type="html"><![CDATA[Weekly Development Log]]></summary></entry><entry><title type="html">Kubernetes</title><link href="http://localhost:4000/otter_song.github.io/devops/kubernetes_concept/" rel="alternate" type="text/html" title="Kubernetes" /><published>2025-11-29T15:13:00+09:00</published><updated>2025-11-29T15:13:00+09:00</updated><id>http://localhost:4000/otter_song.github.io/devops/kubernetes_concept</id><content type="html" xml:base="http://localhost:4000/otter_song.github.io/devops/kubernetes_concept/"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/67/Kubernetes_logo.svg" alt="k8s_logo" /></p>

<hr />

<h3 id="-kubernetes란">📌 Kubernetes란?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>배포, 스케일링, 그리고 컨테이너화된 애플리케이션의 관리를 자동화하는 
오픈 소스 컨테이너 오케스트레이션 엔진이다.
// Cloud Native Computing Foundation(CNCF)이 주관한다.
</code></pre></div></div>

<h3 id="-kubernetes-이름의-유래">📌 Kubernetes 이름의 유래</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>쿠버네티스는 '키잡이(helmsman), 파일럿'을 뜻하는 그리스어에서 유래했다.
K8s는 "K"와 "s" 사이의 8글자를 줄여 표기한 것이다.
</code></pre></div></div>

<h3 id="-kubernetes가-필요한-이유">📌 Kubernetes가 필요한 이유</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로덕션 환경에서는 컨테이너를 안정적으로 관리하고 
중단 없이 애플리케이션을 실행해야 한다.
쿠버네티스는 분산 시스템 운영을 위한 자동화된 프레임워크를 제공한다.
</code></pre></div></div>

<hr />

<h3 id="-kubernetes가-제공하는-기능">🚀 Kubernetes가 제공하는 기능</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1) 서비스 디스커버리 &amp; 로드 밸런싱  
2) 스토리지 오케스트레이션  
3) 자동화된 롤아웃 &amp; 롤백  
4) 자동 빈 패킹 (bin packing)  
5) 자동 복구 (Self-Healing)  
6) 시크릿 &amp; 설정 관리  
7) 배치/CI 작업 실행  
8) 수평 확장 (CPU/명령 기반 자동 스케일링)  
9) 확장성을 고려한 설계 (플러그인/확장 쉬움)
</code></pre></div></div>

<hr />

<h3 id="-kubernetes에-대한-오해">🧩 Kubernetes에 대한 오해</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>쿠버네티스는 PaaS가 아니지만,
PaaS에서 제공하는 배포, 스케일링, 로드밸런싱 기능은 제공한다.
모놀리식이 아닌 선택적 구성 방식이며, 
사용자가 로깅/모니터링을 직접 통합해야 한다.

// 1. 모놀리식(monolithic): 하나로 된 큰 구조
</code></pre></div></div>

<hr />

<h3 id="-kubernetes-요약-정리">📝 Kubernetes 요약 정리</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 특정 언어/프레임워크에 종속되지 않는다.
2. 소스 코드 배포/빌드를 하지 않는다.
3. 애플리케이션 레벨 서비스(예: 이메일, DB)를 제공하지 않는다.
4. 로깅/모니터링/알림을 내장하지 않는다.
5. 선언적 API 기반이다 (YAML 등 사용).
6. 머신 설정/유지보수 자동화 도구가 아니다.
7. 오케스트레이션을 필요 없게 하는 플랫폼이다.

// 오케스트레이션 = 정해진 순서로 자동 작업 실행
</code></pre></div></div>

<hr />

<h3 id="-kubernetes-진화-과정">📌 Kubernetes 진화 과정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>전통적인 배포 → 가상화 → 컨테이너 → Kubernetes 시대
</code></pre></div></div>

<hr />]]></content><author><name>otter song</name></author><category term="DevOps" /><summary type="html"><![CDATA[]]></summary></entry></feed>